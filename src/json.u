use Optional None Some
use Text concat

type Either a b = Left a | Right b

-- | A JSON value represented as a Unison value.
type Json.Value = Object [(Text, Json.Value)]
                | Array [Json.Value]
                | String Text
                | Number Text -- there is no Scientific and Float has no Show/Format yet
                | Bool Boolean
                | Null

Json.parse : Text -> Optional Json.Value
Json.parse t =
  Some (Json.Value.String "TODO")

type Token = Reserved Text -- {}[],
           | Textual Text -- "..."
           | Numeric Text -- 997.6
           | Symbol Text -- null, foo,
           | Err Text


lexString : Text -> Either Text (Text, Text)
lexString t =
  go : Text -> Text -> Either Text (Text, Text)
  go acc rest =
    c = Text.take 1 rest
    case Text.size c of
      0 -> Either.Left "Missing closing \""
      1 ->
        case c of
          "\\"  -> go (acc ++ (Text.take 2 rest)) (Text.drop 2 rest)
          "\""  -> Either.Right ( acc, Text.drop 1 rest)
          other -> go (acc ++ other) (Text.drop 1 rest)
  first = Text.take 1 t
  case first of
    "\"" -> go "" (Text.drop 1 t)
    _    -> Either.Left "A String should start with \""

lexNumber : Text -> Either Text (Text, Text)
lexNumber t =
  go : Text -> Text -> Either Text (Text, Text)
  go acc rest =
    c = Text.take 1 rest
    case Text.size c of
      0 -> Either.Right ( acc, rest)
      1 ->
        case c of
          n | isNumeric n  -> go (acc ++ n) (Text.drop 1 rest)
          _                -> Either.Right (acc, rest)
  first = Text.take 1 t
  case first of
    n | isNumeric n -> go "" t
    _               -> Either.Left "A number should start with a 0-9 or . digit"


-- for now we do not support whitespace
Json.lex : Text -> [Token]
Json.lex t =
    go : [Token] -> Text -> [Token]
    go acc t =
      c = Text.take 1 t
      case Text.size c of
        0 -> acc
        1 ->
            -- no pattern match on text yet
            case c of
              "{"  -> go (acc ++ [Reserved "{"]) (Text.drop 1 t)
              "}"  -> go (acc ++ [Reserved "}"]) (Text.drop 1 t)
              "["  -> go (acc ++ [Reserved "["]) (Text.drop 1 t)
              "]"  -> go (acc ++ [Reserved "]"]) (Text.drop 1 t)
              ":"  -> go (acc ++ [Reserved ":"]) (Text.drop 1 t)
              ","  -> go (acc ++ [Reserved ","]) (Text.drop 1 t)
              "\"" ->
                case lexString t of
                  Either.Right (str, rest) -> go (acc ++ [Textual str]) rest
                  Either.Left err -> [Token.Err err]
              n | isNumeric n ->
                case lexNumber t of
                  Either.Right (str, rest) -> go (acc ++ [Numeric str]) rest
                  Either.Left err -> [Token.Err err]
              _ -> [Token.Err ("Unexpected token: " ++ c)]
    go [] t

Json.format : Json.Value -> Text
Json.format v = case v of
  Json.Value.String s -> "\"" ++ s ++ "\""
  Json.Value.Number f -> f
  Json.Value.Bool true -> "true"
  Json.Value.Bool false -> "false"
  Json.Value.Null -> "null"
  Json.Value.Object props -> Text.concatSeq "{" "}" "," (Sequence.map formatProp props)
  Json.Value.Array els -> Text.concatSeq "[" "]" "," (Sequence.map format els)

isNumeric: Text -> Boolean
isNumeric t =
  -- TODO add Exponent notation support
  case t of
    "."                              -> true
    n | (n >= "0") `band` (n <= "9") -> true
    _                                -> false


band : Boolean -> Boolean -> Boolean
band a b =
  case (a, b) of
    (true, true) -> true
    _            -> false

formatProp : (Text, Json.Value) -> Text
formatProp kv = case kv of
  (k, v) -> "\"" ++ k ++ "\"" ++ ":" ++ (format v)

Sequence.map : (a -> b) -> [a] -> [b]
Sequence.map f as =
  go f acc as i = case at i as of
    None -> acc
    Some a -> go f (acc `snoc` f a) as (i + 1)
  go f [] as 0

Sequence.fold : a -> (a -> a -> a) -> [a] -> a
Sequence.fold zero f as =
  go acc f as i = case at i as of
    None -> acc
    Some t -> go (f acc t ) f as (i + 1)
  go zero f as 0

Text.concat : [Text] -> Text
Text.concat ts = Sequence.fold Text.empty (Text.++) ts

Text.concatSeq : Text -> Text -> Text -> [Text] -> Text
Text.concatSeq head tail sep ts =
    head ++ Text.concat (Sequence.intersperse sep ts) ++ tail

Sequence.intersperse : a -> [a] -> [a]
Sequence.intersperse sep as =
  case at 0 as of
    None -> []
    Some a -> Sequence.cons a (Sequence.prependToAll sep (Sequence.drop 1 as))

Sequence.flatMap : (a -> [a]) -> [a] -> [a]
Sequence.flatMap f as =
  go f acc as i = case at i as of
    None -> acc
    Some a -> go f (acc Sequence.++ (f a) ) as (i + 1)
  go f [] as 0

-- should not be exported
Sequence.prependToAll : a -> [a] -> [a]
Sequence.prependToAll p as = Sequence.flatMap (a -> [p] ++ [a]) as

-- | 'intercalate' @xs xss@ is equivalent to @('concat' ('intersperse' xs xss))@.
-- It inserts the list @xs@ in between the lists in @xss@ and concatenates the
-- result.
--
-- >>> intercalate ", " ["Lorem", "ipsum", "dolor"]
-- "Lorem, ipsum, dolor"
-- intercalate :: [a] -> [[a]] -> [a]
-- intercalate xs xss = concat (intersperse xs xss)

--> "\""
--> Json.format (Json.Value.Object [("foo", Json.Value.Number "123"), ("bar", Json.Value.Array [Json.Value.Null, Json.Value.String "test"])])

--> Json.lex "\"test\""
--> Json.lex "123"
--> Json.lex "12x"
--> Json.lex "[123,456]"


--> [Textual "test"]

--> Json.lex "\"test"

--> Json.lex "[]"

--> lexString "abc"
--> lexString "\"abc\",123,true]"
--> lexString "\"\""
--> lexString ""

--> lexNumber "3.14"
--> lexNumber "3.14,"
> lexNumber "3.14,true]}"
--> lexNumber "abc"
--> lexNumber ""

--> Sequence.at 0 ( lex "\"foo\"")

--> Json.lex "[\"test\"]"

--> [Reserved "[", Textual "test", Reserved "]"]

--> Json.lex "{\"foo\":123}"

--> Json.lex "{\"foo\":123,\"bar\":[null,\"test\"]}"

--> case (Json.parse "{\"foo\":123,\"bar\":[null,\"test\"]}") of Some a -> format a

--> Sequence.at 0 (Json.lex "123")

--> Textual "test"
