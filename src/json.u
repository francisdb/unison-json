use Optional None Some
use Text concat

type Either a b = Left a | Right b

Either.map : (b -> c) -> Either a b -> Either a c
Either.map f e =
  case e of
    Either.Left a  -> Either.Left a
    Either.Right b -> Either.Right (f b)

Either.flatmap : (b -> Either a c) -> Either a b -> Either a c
Either.flatmap f e =
  case e of
    Either.Left a  -> Either.Left a
    Either.Right b -> f b

-- | A JSON value represented as a Unison value.
type Json.Value = Object [(Text, Json.Value)]
                | Array [Json.Value]
                | String Text
                | Number Text -- there is no Scientific and Float has no Show/Format yet
                | Bool Boolean
                | Null

Json.parse : Text -> Optional Json.Value
Json.parse t =
  Some (Json.Value.String "TODO")

type Token = Reserved Text -- {}[],
           | Textual Text -- "..."
           | Numeric Text -- 997.6
           | True
           | False
           | Null
           | Err Text

-- in fact for json this can only be null
lexSymbol : Text -> Either Text (Token, Text)
lexSymbol t =
  -- TODO limit parsing to max 5 chars to avoid DOS
  validate: Text -> Either Text Token
  validate symbol =
    case symbol of
      "null"  -> Either.Right Token.Null
      "true"  -> Either.Right Token.True
      "false" -> Either.Right Token.False
      other   -> Either.Left ("Unknown symbol: " ++ other)

  go : Text -> Text -> Either Text (Token, Text)
  go acc rest =
    tupleLambda a = (a, rest)

    c = Text.take 1 rest
    case Text.size c of
      0 -> map tupleLambda (validate acc)
      1 ->
        case c of
          "]"   -> map tupleLambda (validate acc)
          "}"   -> map tupleLambda (validate acc)
          "}"   -> map tupleLambda (validate acc)
          ":"   -> map tupleLambda (validate acc)
          ","   -> map tupleLambda (validate acc)
          other -> go (acc ++ other) (Text.drop 1 rest)
  go "" t

lexString : Text -> Either Text (Token, Text)
lexString t =
  go : Text -> Text -> Either Text (Token, Text)
  go acc rest =
    c = Text.take 1 rest
    case Text.size c of
      0 -> Either.Left "Missing closing \""
      1 ->
        case c of
          "\\"  -> go (acc ++ (Text.take 2 rest)) (Text.drop 2 rest)
          "\""  -> Either.Right (Textual acc, Text.drop 1 rest)
          other -> go (acc ++ other) (Text.drop 1 rest)
  first = Text.take 1 t
  case first of
    "\"" -> go "" (Text.drop 1 t)
    _    -> Either.Left "A String should start with \""

lexNumber : Text -> Either Text (Token, Text)
lexNumber t =
  go : Text -> Text -> Either Text (Token, Text)
  go acc rest =
    c = Text.take 1 rest
    case Text.size c of
      0 -> Either.Right (Numeric acc, rest)
      1 ->
        if (isNumeric c) then
          go (acc ++ c) (Text.drop 1 rest)
        else
          Either.Right (Numeric acc, rest)
--        case c of
--          n | isNumeric n  -> go (acc ++ n) (Text.drop 1 rest)
--          _                -> Either.Right (Numeric acc, rest)
  first = Text.take 1 t
  case first of
    n | isNumeric n -> go "" t
    _               -> Either.Left "A number should start with a 0-9 or . digit"


-- for now we do not support whitespace
Json.lex : Text -> [Token]
Json.lex t =
    go : [Token] -> Text -> [Token]
    go acc t =
      c = Text.take 1 t
      case Text.size c of
        0 -> acc
        1 ->
            -- no pattern match on text yet
            case c of
              "{"  -> go (acc ++ [Reserved "{"]) (Text.drop 1 t)
              "}"  -> go (acc ++ [Reserved "}"]) (Text.drop 1 t)
              "["  -> go (acc ++ [Reserved "["]) (Text.drop 1 t)
              "]"  -> go (acc ++ [Reserved "]"]) (Text.drop 1 t)
              ":"  -> go (acc ++ [Reserved ":"]) (Text.drop 1 t)
              ","  -> go (acc ++ [Reserved ","]) (Text.drop 1 t)
              "\"" ->
                case lexString t of
                  Either.Right (token, rest) -> go (acc ++ [token]) rest
                  Either.Left err -> [Token.Err err]
              n | isNumeric n ->
                case lexNumber t of
                  Either.Right (token, rest) -> go (acc ++ [token]) rest
                  Either.Left err -> [Token.Err err]
              other ->
                case lexSymbol t of
                  Either.Right (token, rest) -> go (acc ++ [token]) rest
                  Either.Left err -> [Token.Err err]
    go [] t


Json.format : Json.Value -> Text
Json.format v = case v of
  Json.Value.String s -> "\"" ++ s ++ "\""
  Json.Value.Number f -> f
  Json.Value.Bool true -> "true"
  Json.Value.Bool false -> "false"
  Json.Value.Null -> "null"
  Json.Value.Object props -> Text.concatSeq "{" "}" "," (Sequence.map formatProp props)
  Json.Value.Array els -> Text.concatSeq "[" "]" "," (Sequence.map format els)

isNumeric: Text -> Boolean
isNumeric t =
  -- TODO add Exponent notation support
  case t of
    "."                              -> true
    n | (n >= "0") `band` (n <= "9") -> true
    _                                -> false


band : Boolean -> Boolean -> Boolean
band a b =
  case (a, b) of
    (true, true) -> true
    _            -> false

formatProp : (Text, Json.Value) -> Text
formatProp kv = case kv of
  (k, v) -> "\"" ++ k ++ "\"" ++ ":" ++ (format v)

Sequence.map : (a -> b) -> [a] -> [b]
Sequence.map f as =
  go f acc as i = case at i as of
    None -> acc
    Some a -> go f (acc `snoc` f a) as (i + 1)
  go f [] as 0

Sequence.fold : a -> (a -> a -> a) -> [a] -> a
Sequence.fold zero f as =
  go acc f as i = case at i as of
    None -> acc
    Some t -> go (f acc t ) f as (i + 1)
  go zero f as 0

Text.concat : [Text] -> Text
Text.concat ts = Sequence.fold "" (Text.++) ts

Text.concatSeq : Text -> Text -> Text -> [Text] -> Text
Text.concatSeq head tail sep ts =
    head ++ Text.concat (Sequence.intersperse sep ts) ++ tail

Sequence.intersperse : a -> [a] -> [a]
Sequence.intersperse sep as =
  case at 0 as of
    None -> []
    Some a -> Sequence.cons a (Sequence.prependToAll sep (Sequence.drop 1 as))

Sequence.flatMap : (a -> [a]) -> [a] -> [a]
Sequence.flatMap f as =
  go f acc as i = case at i as of
    None -> acc
    Some a -> go f (acc Sequence.++ (f a) ) as (i + 1)
  go f [] as 0

-- should not be exported
Sequence.prependToAll : a -> [a] -> [a]
Sequence.prependToAll p as = Sequence.flatMap (a -> [p] ++ [a]) as

-- | 'intercalate' @xs xss@ is equivalent to @('concat' ('intersperse' xs xss))@.
-- It inserts the list @xs@ in between the lists in @xss@ and concatenates the
-- result.
--
-- >>> intercalate ", " ["Lorem", "ipsum", "dolor"]
-- "Lorem, ipsum, dolor"
-- intercalate :: [a] -> [[a]] -> [a]
-- intercalate xs xss = concat (intersperse xs xss)

--> "\""
--> Json.format (Json.Value.Object [("foo", Json.Value.Number "123"), ("bar", Json.Value.Array [Json.Value.Null, Json.Value.String "test"])])
--> Json.format (Json.Value.String "123")
--> Json.format (Json.Value.Array [])
--> Text.concat ["foo", "bar"]

--> Sequence.map format [Json.Value.String "123"]

--> Json.lex "\"test\""
--> Json.lex "123"
--> Json.lex "12x"
--> Json.lex "[123,456]"


--> [Textual "test"]

--> lexString "abc"
> lexString "\"abc\",123,true]"
--> lexString "\"\""
--> lexString ""

--> lexNumber "3.14"
--> lexNumber "3.14,"
> lexNumber "3.14,true]}"
--> lexNumber "abc"
--> lexNumber ""
> lexSymbol "true"
> lexSymbol "null,true]}"
> lexSymbol "null]}"
> lexSymbol "abc"


--> Sequence.at 0 ( lex "\"foo\"")

> Json.lex "[\"test\"]"
> Json.lex "[\"test\",\"bar\"]"
> Json.lex "[]"
> Json.lex "\"test\""
--> Json.lex "\"test"
> Json.lex "{\"foo\":123}"
> Json.lex "true"
--> Json.lex "[null]"
--> Json.lex "{\"foo\":123,\"bar\":[null,\"test\"]}"

--> [Reserved "[", Textual "test", Reserved "]"]



--> case (Json.parse "{\"foo\":123,\"bar\":[null,\"test\"]}") of Some a -> format a

--> Sequence.at 0 (Json.lex "123")

> [Textual "test"]
> Err "t"

