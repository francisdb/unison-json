use Optional None Some
use Text concat
use Either Left Right

use Json.Internal.Token Reserved Null True False Numeric Textual Err

-- ===================== this stuff is missing in the stdlib =====

type Either a b = Left a | Right b

namespace Either where

  map : (b -> c) -> Either a b -> Either a c
  map f e =
    case e of
      Left a  -> Left a
      Right b -> Right (f b)

  flatmap : (b -> Either a c) -> Either a b -> Either a c
  flatmap f e =
    case e of
      Left a  -> Left a
      Right b -> f b

namespace Boolean where

  (==) : Boolean -> Boolean -> Boolean
  (==) a b =
    case (a, b) of
      (true, true)   -> true
      (false, false) -> true
      _              -> false

  -- TODO would we need a lazy version that avoids evaluating the second arg if not needed?
  (&&) : Boolean -> Boolean -> Boolean
  (&&) a b =
    case (a, b) of
      (true, true) -> true
      _            -> false

namespace Sequence where

  map : (a -> b) -> [a] -> [b]
  map f as =
    go f acc i = case at i as of
      None -> acc
      Some a -> go f (acc `snoc` f a) (i + 1)
    go f [] 0

  foldl : (b -> a -> b) -> b -> [a] -> b
  foldl f b s =
    go i acc = case Sequence.at i s of
      Some a -> go (i + 1) (f acc a)
      None -> acc
    go 0 b

  (==) : (a -> a -> Boolean) -> [a] -> [a] -> Boolean
  (==) eq s1 s2 =
    go i = case (Sequence.at i s1, Sequence.at i s2) of
      (Some e1, Some e2) ->
        if (eq e1 e2) then
          (go (i + 1))
        else
          false
      (None, None) -> true
      _            -> false
    go 0

  intersperse : a -> [a] -> [a]
  intersperse sep as =
    case Sequence.at 0 as of
      None -> []
      Some a -> Sequence.cons a (Sequence.Internal.prependToAll sep (Sequence.drop 1 as))

  flatMap : (a -> [a]) -> [a] -> [a]
  flatMap f as =
    go f acc as i = case at i as of
      None -> acc
      Some a -> go f (acc Sequence.++ (f a) ) as (i + 1)
    go f [] as 0

  namespace Internal where

    -- should not be exported
    prependToAll : a -> [a] -> [a]
    prependToAll p as = Sequence.flatMap (a -> [p] ++ [a]) as

namespace Text where

  concat : [Text] -> Text
  concat ts = Sequence.foldl (Text.++) "" ts

  concatSeq : Text -> Text -> Text -> [Text] -> Text
  concatSeq head tail sep ts =
    head ++ Text.concat (Sequence.intersperse sep ts) ++ tail

namespace Pair where

  (==) : (a -> a -> Boolean) -> (b -> b -> Boolean) -> (a, b) -> (a, b) -> Boolean
  (==) aeq beq p1 p2 =
    case (p1, p2) of
      ((a1, b1),(a2, b2)) -> (aeq a1 a2) && (beq b1 b2)

  fst : (a,b) -> a
  fst p = case p of
    (a,b) -> a

  snd : (a,b) -> b
  snd p = case p of
    (a,b) -> b

  with : b -> a -> (a, b)
  with b a = (a, b)

namespace Test where

    --Test.test : Text (Text, Boolean) -> Text
    --Test.test text ass =
    --  case ass of
    --    (t, false) -> ""
    --    (t, true) -> ""

  test : Text -> Boolean -> (Text, Boolean)
  test text assertion =
    if assertion then
      ("✅ " ++ text, true)
    else
      ("❌" ++ text, false)


-- =======================================================================

-- | A JSON value represented as a Unison value.
type Json.Value = Object [(Text, Json.Value)]
                | Array [Json.Value]
                | String Text
                | Number Text -- there is no Scientific and Float has no Show/Format yet
                | Bool Boolean
                | Null

namespace Json where

  (Value.==) : Json.Value -> Json.Value -> Boolean
  (Value.==) a b =
    case (a,b) of
      (Json.Value.Null, Json.Value.Null)             -> true
      (Json.Value.Bool b1, Json.Value.Bool b2)       -> b1 == b2
      (Json.Value.String s1, Json.Value.String s2)   -> s1 == s2
      (Json.Value.Number s1, Json.Value.Number s2)   -> s1 == s2
      (Json.Value.Array a1, Json.Value.Array a2)     -> a1 == a2
      (Json.Value.Object o1, Json.Value.Object o2)   -> o1 == o2 -- TODO we should sort by key first
      _                                              -> false

  format : Json.Value -> Text
  format v = case v of
    Json.Value.String s -> "\"" ++ s ++ "\""
    Json.Value.Number f -> f
    Json.Value.Bool true -> "true"
    Json.Value.Bool false -> "false"
    Json.Value.Null -> "null"
    Json.Value.Object props -> Text.concatSeq "{" "}" "," (Sequence.map Internal.formatProp props)
    Json.Value.Array els -> Text.concatSeq "[" "]" "," (Sequence.map Json.format els)

  parse : Text -> Either Text Json.Value
  parse t =
    lexed = Json.lex t
    Either.flatmap (validateRemainingEmpty) (parseTokens lexed)

  validateRemainingEmpty : (a, [Json.Internal.Token]) -> Either Text a
  validateRemainingEmpty tokens = case tokens of
    (value, rest) | Sequence.size rest == 0 -> Right value
    (_    , rest) -> Left "Unexpected tokens found after root element" --TODO point to the location

  parseTokens : [Json.Internal.Token] -> Either Text (Json.Value, [Json.Internal.Token])
  parseTokens tokens =
    first = Sequence.at 0 tokens
    case first of
      Some (Reserved "{") -> Json.parseObject (Sequence.drop 1 tokens)
      Some (Reserved "[") -> Json.parseArray (Sequence.drop 1 tokens)
      Some (other)        -> Either.map (Pair.with (Sequence.drop 1 tokens)) (Json.parseValue other)
      None                -> Left "Can't parse empty document to JSON"


  namespace Internal where

    formatProp : (Text, Json.Value) -> Text
    formatProp kv = case kv of
      (k, v) -> "\"" ++ k ++ "\"" ++ ":" ++ (Json.format v)

type Json.Internal.Token = Reserved Text -- {}[],:
                         | Textual Text -- "..."
                         | Numeric Text -- 997.6
                         | True
                         | False
                         | Null
                         | Err Text

(Json.Internal.Token.==) : Json.Internal.Token -> Json.Internal.Token -> Boolean
(Json.Internal.Token.==) a b =
  case (a,b) of
    (Null, Null)               -> true
    (True, True)               -> true
    (False, False)             -> false
    (Reserved t1, Reserved t2) -> t1 == t2
    (Textual t1, Textual t2)   -> t1 == t2
    (Numeric n1, Numeric n2)   -> n1 == n2
    (Err t1, Err t2)           -> t1 == t2
    _                                                                  -> false

(Json.Internal.TokenArrEq.==) : [Json.Internal.Token] -> [Json.Internal.Token] -> Boolean
(Json.Internal.TokenArrEq.==) = (Sequence.==) (Json.Internal.Token.==)


isNumeric: Text -> Boolean
isNumeric t =
  -- TODO add Exponent notation support
  case t of
    "."                              -> true
    n | (n >= "0") && (n <= "9")     -> true
    _                                -> false



-- in fact for json this can only be null
lexSymbol : Text -> Either Text (Json.Internal.Token, Text)
lexSymbol t =
  -- TODO limit parsing to max 5 chars to avoid DOS
  validate: Text -> Either Text Json.Internal.Token
  validate symbol =
    case symbol of
      "null"  -> Right Null
      "true"  -> Right True
      "false" -> Right False
      other   -> Left ("Unknown symbol: " ++ other)

  go : Text -> Text -> Either Text (Json.Internal.Token, Text)
  go acc rest =
    -- TODO was unable to define his in a lambda
    tupleLambda a = (a, rest)

    c = Text.take 1 rest
    case Text.size c of
      0 -> map tupleLambda (validate acc)
      1 ->
        case c of
          "]"   -> map tupleLambda (validate acc)
          "}"   -> map tupleLambda (validate acc)
          "}"   -> map tupleLambda (validate acc)
          ":"   -> map tupleLambda (validate acc)
          ","   -> map tupleLambda (validate acc)
          other -> go (acc ++ other) (Text.drop 1 rest)
  go "" t

lexString : Text -> Either Text (Json.Internal.Token, Text)
lexString t =
  go : Text -> Text -> Either Text (Json.Internal.Token, Text)
  go acc rest =
    c = Text.take 1 rest
    case Text.size c of
      0 -> Left "Missing closing \""
      1 ->
        case c of
          "\\"  -> go (acc ++ (Text.take 2 rest)) (Text.drop 2 rest)
          "\""  -> Right (Textual acc, Text.drop 1 rest)
          other -> go (acc ++ other) (Text.drop 1 rest)
  first = Text.take 1 t
  case first of
    "\"" -> go "" (Text.drop 1 t)
    _    -> Left "A String should start with \""

lexNumber : Text -> Either Text (Json.Internal.Token, Text)
lexNumber t =
  go : Text -> Text -> Either Text (Json.Internal.Token, Text)
  go acc rest =
    c = Text.take 1 rest
    case Text.size c of
      0 -> Right (Numeric acc, rest)
      1 ->
        case c of
          n | isNumeric n  -> go (acc ++ n) (Text.drop 1 rest)
          _                -> Right (Numeric acc, rest)
  first = Text.take 1 t
  case first of
    n | isNumeric n -> go "" t
    _               -> Left "A number should start with a 0-9 or . digit"


-- for now we do not support whitespace
Json.lex : Text -> [Json.Internal.Token]
Json.lex t =
    go : [Json.Internal.Token] -> Text -> [Json.Internal.Token]
    go acc t =
      c = Text.take 1 t
      case Text.size c of
        0 -> acc
        1 ->
            -- no pattern match on text yet
            case c of
              "{"  -> go (acc ++ [Reserved "{"]) (Text.drop 1 t)
              "}"  -> go (acc ++ [Reserved "}"]) (Text.drop 1 t)
              "["  -> go (acc ++ [Reserved "["]) (Text.drop 1 t)
              "]"  -> go (acc ++ [Reserved "]"]) (Text.drop 1 t)
              ":"  -> go (acc ++ [Reserved ":"]) (Text.drop 1 t)
              ","  -> go (acc ++ [Reserved ","]) (Text.drop 1 t)
              "\"" ->
                case lexString t of
                  Right (token, rest) -> go (acc ++ [token]) rest
                  Left err -> [Err err]
              n | isNumeric n ->
                case lexNumber t of
                  Right (token, rest) -> go (acc ++ [token]) rest
                  Left err -> [Err err]
              other ->
                case lexSymbol t of
                  Right (token, rest) -> go (acc ++ [token]) rest
                  Left err -> [Err err]
    go [] t

Json.parseValue : Json.Internal.Token -> Either Text Json.Value
Json.parseValue t = case t of
  Textual t  -> Right (Json.Value.String t)
  Numeric n  -> Right (Json.Value.Number n)
  Null       -> Right Json.Value.Null
  True       -> Right (Json.Value.Bool true)
  False      -> Right (Json.Value.Bool false)
  Reserved r -> Left ("Unexpected token: " ++ r)
  Err e      -> Left e

Json.parseArray : [Json.Internal.Token] -> Either Text (Json.Value, [Json.Internal.Token])
Json.parseArray tokens =
  go : [Json.Value] -> [Json.Internal.Token] -> Either Text (Json.Value, [Json.Internal.Token])
  go acc tokens =
    case (Json.parseTokens tokens) of
      Right (el, tokens') ->
        t = Sequence.at 0 tokens'
        acc' = acc `snoc` el
        case t of
          None                                    -> Left "unclosed object"
          Some (Reserved ",") -> go acc' (Sequence.drop 1 tokens')
          Some (Reserved "]") -> Right (Json.Value.Array acc', Sequence.drop 1 tokens')
      Left err -> Left err
  case (Sequence.at 0) tokens of
    Some (Reserved "]") -> Right (Json.Value.Array [], Sequence.drop 1 tokens)
    _ -> go [] tokens

Json.parseObject : [Json.Internal.Token] -> Either Text  (Json.Value, [Json.Internal.Token])
Json.parseObject tokens = Left "TODO"

--    json_object = {}
--
--    t = tokens[0]
--    if t == JSON_RIGHTBRACE:
--        return json_object, tokens[1:]
--
--    while True:
--        json_key = tokens[0]
--        if type(json_key) is str:
--            tokens = tokens[1:]
--        else:
--            raise Exception('Expected string key, got: {}'.format(json_key))
--
--        if tokens[0] != JSON_COLON:
--            raise Exception('Expected colon after key in object, got: {}'.format(t))
--
--        json_value, tokens = parse(tokens[1:])
--
--        json_object[json_key] = json_value
--
--        t = tokens[0]
--        if t == JSON_RIGHTBRACE:
--            return json_object, tokens[1:]
--        elif t != JSON_COMMA:
--            raise Exception('Expected comma after pair in object, got: {}'.format(t))
--
--        tokens = tokens[1:]
--
--    raise Exception('Expected end-of-object brace')




namespace Json.Internal where

  (JsonArrEq.==) : [Json.Value] -> [Json.Value]-> Boolean
  (JsonArrEq.==) = (Sequence.==) (Json.Value.==)

  (JsonObjEq.==) : [(Text, Json.Value)] -> [(Text, Json.Value)] -> Boolean
  (JsonObjEq.==) = (Sequence.==) ((Pair.==) (Text.==) (Json.Value.==))




-- ==== Tests below, to be transformed in real unit tests =======================


> Json.format (Json.Value.Object [("foo", Json.Value.Number "123"), ("bar", Json.Value.Array [Json.Value.Null, Json.Value.String "test"])])
--> Json.format (Json.Value.String "123")
--> Json.format (Json.Value.Array [])
--> Text.concat ["foo", "bar"]

--> Sequence.map format [Json.Value.String "123"]

--> Json.lex "\"test\""
--> Json.lex "123"
--> Json.lex "12x"
--> Json.lex "[123,456]"


--> [Textual "test"]

--> lexString "abc"
--> lexString "\"abc\",123,true]"
--> lexString "\"\""
--> lexString ""

--> lexNumber "3.14"
--> lexNumber "3.14,"
--> lexNumber "3.14,true]}"
--> lexNumber "abc"
--> lexNumber ""
--> lexSymbol "true"
--> lexSymbol "null,true]}"
--> lexSymbol "null]}"
--> lexSymbol "abc"


--> Sequence.at 0 ( lex "\"foo\"")

--> Json.lex "[\"test\"]"
--> Json.lex "[\"test\",\"bar\"]"
--> Json.lex "[]"
--> Json.lex "\"test\""
--> Json.lex "\"test"
--> Json.lex "{\"foo\":123}"
--> Json.lex "true"
--> Json.lex "[null]"

expected = [ Reserved "{"
           , Textual "foo"
           , Reserved ":"
           , Numeric "123"
           , Reserved ","
           , Textual "bar"
           , Reserved ":"
           , Reserved "["
           , Null
           , Reserved ","
           , Textual "test"
           , Reserved "]"
           , Reserved "}"
           ]

> test "Lexing json object" ((Json.lex "{\"foo\":123,\"bar\":[null,\"test\"]}") == expected)
--> Json.lex "{\"foo\":123,\"bar\":[null,\"test\"]}"

--> [Reserved "[", Textual "test", Reserved "]"]

--> format (Json.Value.Array [])
--> Sequence.at 0 (Json.lex "123")

--> [Textual "test"]
--> Err "t"

(NatPair.==) : (Nat, Nat) -> (Nat, Nat) -> Boolean
(NatPair.==) = ((Pair.==) (Nat.==) (Nat.==))

--> (Json.Value.==) Json.Value.Null Json.Value.Null
--> Json.Value.Null == Json.Value.Null

--> Json.Value.Array [Json.Value.Null] == Json.Value.Array [Json.Value.Null]

--> Json.parse "123"
--> Json.parse ":"
--> Json.parse ""
> Json.parse "null"
> Json.parse "true"
> Json.parse "[]"
> Json.parse "[1,2,[true,false]]"
> Json.parse "{\"foo\":123,\"bar\":[null,\"test\"]}"
> Json.parse "\"\\\"\"" -- FIXME handle escapes, see https://json.org/


--> case (Json.parse "{\"foo\":123,\"bar\":[null,\"test\"]}") of Some a -> Json.format a
